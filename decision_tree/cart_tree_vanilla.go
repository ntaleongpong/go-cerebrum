package decisiontree

import (
	// "github.com/ldsec/lattigo/v2/ckks"
	// "github.com/perm-ai/go-cerebrum/utility"
)

// methods to create:

// unique values- find a unique value for a column in a dataset
// count values- count the number of classes input (column -1 or last column)
// partition- for each row, check if the example belongs to the "true" row or the "false row"
// gini purity- find gini impurity
// information gain- find information gain from gini
// find the best split-

// final method to put everything together (build_tree)

// classify method for testing

// class to create:

// question class- store the questions asked
// 				has a method that checks whether the input example match the value stored in the question struct

// leaf class- 

// decision node class-

// Example Data- 


// need to tell number of class



// type question struct {
	
// }

// type leaf struct {

// }

// type decisionNode struct {

// }

// func findUniqueValue() {
// 	// find every unique value in an array
	
// }



// func countClass(labelColumn []float64) {
	
// 	//find how many class is in a dataset
// 	// ***might not need if number of classes are specified by data owner***
	
// }

// func contains(s []int, e int) bool {
//     for a := range s {
//         if a == e {
//             return true
//         }
//     }
//     return false
// }

// testSlice := []float64{1,0,0,1,2}

// func partition() {
// 	// Partitions a dataset.
//     // For each row in the dataset, check if it matches the question. If
//     // so, add it to 'true rows', otherwise, add it to 'false rows'.
    

// }

// func gini() {

// }



